#version 330

struct Attenuation
{
    float constant;
    float linear;
    float exponent;
};

struct PointLight
{
	vec3 position;
	vec3 colour;
	float intensity;
	Attenuation attenuation;
};

struct SpotLight
{
    PointLight pl;
    vec3 conedir;
    float cutoff;
};

struct DirectionalLight
{
    vec3 colour;
    vec3 direction;
    float intensity;
};

struct Material
{
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    int hasTexture;
    int hasNormalMap;
    float reflectance;
};

struct Fog
{
    int activeFog;
    vec3 colour;
    float density;
    float gradient;
};

const int MAX_POINT_LIGHTS = 4;
const int MAX_SPOT_LIGHTS = 4;
const int TEXTURE_RESOLUTION_X = 300;
const int TEXTURE_RESOLUTION_Y = 225;

in vec2 pass_textureCoordinates;
in vec3 pass_mvtToCamera;
in mat3 pass_mvTangentSpace;
in vec3 pass_mvPosition;
in vec3 pass_mvNormal;
in vec4 pass_mlightviewVertexPos;

uniform sampler2D textureSampler;
uniform sampler2D normalMapSampler;
uniform sampler2D shadowMapSampler;
uniform vec3 ambientLight;
uniform float specularPower;
uniform Material material;
uniform Fog fog;
uniform PointLight pointLights[MAX_POINT_LIGHTS];
uniform SpotLight spotLights[MAX_SPOT_LIGHTS];
uniform DirectionalLight directionalLight;

layout ( location = 0 ) out vec4 out_colour;

vec4 ambientC;
vec4 diffuseC;
vec4 speculrC;

vec2 rotateUV(vec2 uv, float rotation)
{
    float mid = 0.5;
    return vec2(
        cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,
        cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid
    );
}

void setupColours(Material material, vec2 textCoord)
{
    if (material.hasTexture == 1)
    {
        ambientC = texture(textureSampler, textCoord);
        diffuseC = ambientC;
        speculrC = ambientC;
    }
    else
    {
        ambientC = material.ambient;
        diffuseC = material.diffuse;
        speculrC = material.specular;
    }
}

vec3 calcDiffuse(PointLight lightIn, vec3 lightDirectionIn, vec3 pass_mvtToCameraIn, vec3 normalIn, float attenuationFactorIn)
{
    // Diffuse Light

	float diffuseFactor = max(dot(normalIn, lightDirectionIn), 0.0);

	return  (diffuseC.xyz * lightIn.intensity * diffuseFactor * material.reflectance * lightIn.colour) / attenuationFactorIn;
}

vec3 calcSpecularFromDir(PointLight lightIn, vec3 lightDirectionIn,  vec3 pass_mvtToCameraIn, vec3 normalIn, float attenuationFactorIn, vec3 fromLightDirIn)
{
    // Specular Light

	vec3 reflected_light = normalize(reflect(fromLightDirIn, normalIn));
	float specularFactor = max(dot(reflected_light, pass_mvtToCameraIn), 0.0);
	specularFactor = pow(specularFactor, specularPower);

	return (speculrC.xyz * lightIn.intensity * specularFactor * material.reflectance * lightIn.colour) / attenuationFactorIn;
}

vec3 calcSpecular(PointLight lightIn, vec3 lightDirectionIn,  vec3 pass_mvtToCameraIn, vec3 normalIn, float attenuationFactorIn)
{
	return calcSpecularFromDir(lightIn, lightDirectionIn, pass_mvtToCameraIn, normalIn, attenuationFactorIn, -lightDirectionIn);
}

float calcAttenuationFactor(PointLight lightIn, vec3 lightDirectionIn)
{
	float distance = length(lightDirectionIn);

	return  lightIn.attenuation.constant + (lightIn.attenuation.linear * distance) + (lightIn.attenuation.exponent * distance * distance);
}

vec3 diffuse;
vec3 specular;

void calcPointLightFromDir(PointLight lightIn, vec3 normalIn, vec3 unitVectorToCameraIn, vec3 fromLightDirIn)
{
	diffuse = vec3(0.0);
	specular = vec3(0.0);

	vec3 light_direction = pass_mvTangentSpace * (lightIn.position - pass_mvPosition);
    light_direction.x *= TEXTURE_RESOLUTION_X / TEXTURE_RESOLUTION_Y;
	vec3 to_light_dir = normalize(light_direction);

	// Apply Attenuation
	float attFactor = calcAttenuationFactor(lightIn, to_light_dir);

	diffuse = calcDiffuse(lightIn, to_light_dir, unitVectorToCameraIn, normalIn, attFactor);
	specular = calcSpecularFromDir(lightIn, to_light_dir, unitVectorToCameraIn, normalIn, attFactor, fromLightDirIn);
}

void calcPointLight(PointLight lightIn, vec3 normalIn, vec3 unitVectorToCameraIn)
{
	vec3 light_direction = pass_mvTangentSpace * (lightIn.position - pass_mvPosition);
    light_direction.x *= TEXTURE_RESOLUTION_X / TEXTURE_RESOLUTION_Y;
	vec3 to_light_dir = normalize(light_direction);

	calcPointLightFromDir(lightIn, normalIn, unitVectorToCameraIn, -to_light_dir);
}

void calcSpotLight(SpotLight light, vec3 normalIn, vec3 unitVectorToCameraIn)
{
	diffuse = vec3(0.0);
	specular = vec3(0.0);

    vec3 light_direction = pass_mvTangentSpace * (light.pl.position - pass_mvPosition);
    light_direction.x *= TEXTURE_RESOLUTION_X / TEXTURE_RESOLUTION_Y;
    vec3 to_light_dir  = normalize(light_direction);

    vec3 from_light_dir  = -to_light_dir;
    float spot_alfa = dot(from_light_dir, pass_mvTangentSpace * normalize(light.conedir));

    if ( spot_alfa > light.cutoff ) 
    {
        calcPointLightFromDir(light.pl, normalIn, unitVectorToCameraIn, from_light_dir);
        
        float factor = (1.0f - (1.0f - spot_alfa) / (1.0f - light.cutoff));
        diffuse *= factor;
        specular *= factor;
    }
}

void calcDirectionalLight(DirectionalLight lightIn, vec3 unitVectorToCameraIn, vec3 normalIn)
{
	diffuse = vec3(0.0);
	specular = vec3(0.0);
    // Diffuse Light
    float diffuseFactor = max(dot(normalIn, pass_mvTangentSpace * normalize(lightIn.direction)), 0.0);
    diffuse = diffuseC.xyz * lightIn.colour * lightIn.intensity * diffuseFactor;

    // Specular Light
    vec3 from_light_dir =  pass_mvTangentSpace * (-normalize(lightIn.direction));
    vec3 reflected_light = normalize(reflect(from_light_dir , normalIn));
    float specularFactor = max(dot(reflected_light, unitVectorToCameraIn), 0.0);
    specularFactor = pow(specularFactor, specularPower);
    specular = speculrC.xyz * lightIn.intensity  * specularFactor * material.reflectance * lightIn.colour;
}

vec4 calcFog(vec3 pos, vec4 colour, Fog fog)
{
    float distance = length(pos);
    float fogFactor = 1.0f / exp(pow((distance * fog.density), fog.gradient));
    fogFactor = clamp( fogFactor, 0.0f, 1.0f );

    vec3 resultColour = mix(fog.colour, colour.xyz, fogFactor);
    return vec4(resultColour.xyz, colour.w);
}

vec3 calcNormal(Material material, vec3 normal, vec2 text_coord)
{
    vec3 newNormal = normal;

    if ( material.hasNormalMap == 1 )
    {
        newNormal = normalize(texture(normalMapSampler, text_coord, -1.0f).rgb * 2.0f - 1.0f);
    }

    return newNormal;
}

vec2 poissonDisk[16] = vec2[]( 
   vec2( -0.94201624, -0.39906216 ), 
   vec2( 0.94558609, -0.76890725 ), 
   vec2( -0.094184101, -0.92938870 ), 
   vec2( 0.34495938, 0.29387760 ), 
   vec2( -0.91588581, 0.45771432 ), 
   vec2( -0.81544232, -0.87912464 ), 
   vec2( -0.38277543, 0.27676845 ), 
   vec2( 0.97484398, 0.75648379 ), 
   vec2( 0.44323325, -0.97511554 ), 
   vec2( 0.53742981, -0.47373420 ), 
   vec2( -0.26496911, -0.41893023 ), 
   vec2( 0.79197514, 0.19090188 ), 
   vec2( -0.24188840, 0.99706507 ), 
   vec2( -0.81409955, 0.91437590 ), 
   vec2( 0.19984126, 0.78641367 ), 
   vec2( 0.14383161, -0.14100790 ) 
);

// Returns a random number based on a vec3 and an int.
float random(vec3 seed, int i){
	vec4 seed4 = vec4(seed,i);
	float dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));
	return fract(sin(dot_product) * 43758.5453);
}

float calcShadow(vec4 positionIn, vec3 NIn, DirectionalLight lightIn)
{
    vec3 projCoords = (positionIn.xyz) / positionIn.w;

  	projCoords = clamp(projCoords, 0.0f, 1.0f);

	if(projCoords.z > 1.0f)
	{
		return 1.0f;
	}

	vec3 N = normalize(NIn);
	vec3 L = normalize(-lightIn.direction);

    float bias = max(0.05 * (1.0 - dot(NIn, L)), 0.005);  // calc bias (to avoid 'shadow acne' // moiré pattern aliasing)
	float cosTheta = tan(cos(clamp( dot( NIn,L ), 0.0f ,1.0f)));
	//bias = clamp(max(bias * cosTheta, bias + biasOffset), bias, bias + biasOffset);
	bias = max(0.025f * cosTheta, 0.05f);  // calc bias (to avoid 'shadow acne' // moiré pattern aliasing)

	float shadowFactor = 0.0f;
	float textDepth0 = texture(shadowMapSampler, projCoords.xy).r; 

	if((projCoords.z - bias)/positionIn.w >= textDepth0)
	{
		shadowFactor = 1.0f;
	}

	vec2 inc = 1.0 / textureSize(shadowMapSampler, 0);
    int length = 4;
	for(int row = -length; row <= length; ++row)
	{
	    for(int col = -length; col <= length; ++col)
	    {
	        float textDepth = texture(shadowMapSampler, projCoords.xy + vec2(row, col) * inc).z; 
	        shadowFactor += (projCoords.z - bias) / positionIn.w >= textDepth ? 1.0f : 0.0f;
	    }
	}
	shadowFactor /= (length*2.0f+1.0f)*(length*2.0f+1.0f) + 1;

	float shadowFactor2 = 1.0f;
	for (int i=0;i<4;i++)
	{
		// use either :
		//  - Always the same samples.
		//    Gives a fixed pattern in the shadow, but no noise
		// int index = i;
		//  - A random sample, based on the pixel's screen location. 
		//    No banding, but the shadow moves with the camera, which looks weird.
		// int index = int(16.0*random(gl_FragCoord.xyy, i))%16;
		//  - A random sample, based on the pixel's positionIn in world space.
		//    The positionIn is rounded to the millimeter to avoid too much aliasing
		int index = int(16.0*random(floor(pass_mvPosition.xyz*1000.0), i))%16;
			
		if ( texture(shadowMapSampler, projCoords.xy + poissonDisk[index]/700.0f).r  <  (projCoords.z-bias)/positionIn.w )
		{
			shadowFactor2 -= 0.2f;
		}
	}
	shadowFactor2 = clamp(shadowFactor2, 0.0f, 1.0f);
	shadowFactor = (shadowFactor * 1.5f + shadowFactor2 * 0.5f) / 2.0f;
	shadowFactor = clamp(shadowFactor, 0.0f, 1.0f);

    return 1.0f - shadowFactor;
}

void main(void){

    setupColours(material, pass_textureCoordinates);

	if(ambientC.a<0.5f)
	{
		discard;
	}

	vec3 currNormal = calcNormal(material, pass_mvNormal, pass_textureCoordinates);
	vec3 unitVectorToCamera = normalize(pass_mvtToCamera);

	vec3 totalDiffuse = vec3(0.0f);
	vec3 totalSpecular = vec3(0.0f);
	
	calcDirectionalLight(directionalLight, unitVectorToCamera, currNormal);
	
	totalDiffuse = totalDiffuse + diffuse;
	totalSpecular = totalSpecular + specular;

	for(int i=0;i<4;i++)
	{
		PointLight light = pointLights[i];
		if(light.intensity > 0)
		{
			calcPointLight(light, currNormal, unitVectorToCamera);

			totalDiffuse = totalDiffuse + diffuse;
			totalSpecular = totalSpecular + specular;
		}

		SpotLight spotLight = spotLights[i];
		if(spotLight.pl.intensity > 0)
		{
			calcSpotLight(spotLight, currNormal, unitVectorToCamera);

			totalDiffuse = totalDiffuse + diffuse;
			totalSpecular = totalSpecular + specular;
		}
	}
	totalDiffuse = max(totalDiffuse, 0.2);

	float shadowFactor = calcShadow(pass_mlightviewVertexPos, currNormal, directionalLight);

	out_colour =  clamp(ambientC * vec4(ambientLight, 1) + ambientC * vec4(totalDiffuse, 1.0f) * shadowFactor + vec4(totalSpecular, 1.0f) * shadowFactor, 0.0f, 1.0f);

	if ( fog.activeFog == 1 ) 
	{
		out_colour = calcFog(pass_mvPosition, out_colour, fog);
	}
}